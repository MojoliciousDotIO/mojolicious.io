<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>mojolicious.io</title>
        <link>https://mojolicious.io/blog/</link>
        <atom:link href="https://mojolicious.io/blog/index.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of mojolicious.io</description>
        <generator>Statocles 0.093</generator>
        <item>
            <title>Writing Extensible Controllers</title>
            <link>https://mojolicious.io/blog/2019/01/28/writing-extensible-controllers/</link>
            <guid>https://mojolicious.io/blog/2019/01/28/writing-extensible-controllers/</guid>
            <description><![CDATA[
                <p>Once I have a <a href="https://mojolicious.io/blog/2019/01/21/writing-reusable-controllers">reusable
controller</a>, how do
I extend it? Object-oriented programming gives me a couple ways of
extending a controller through code: Inheritance and composition. But,
we need to write our controller so that it&#39;s easy to inherit or compose.</p>

<h1>Don&#39;t Render, Stash</h1>

<p>First, this means we shouldn&#39;t call <a href="https://mojolicious.org/perldoc/Mojolicious/Controller#render">the <code>render</code>
method</a>
ourselves (unless we have a good reason, but we&#39;ll get to that later).
The <code>render</code> method can only ever be called once, so we should only call
it after we&#39;ve gathered all the data we want.</p>

<pre><code># This method cannot easily be used by a subclass, since it explicitly
# calls render()
sub list {
    my ( $c ) = @_;
    my $resultset_class = $c-&gt;stash( &#39;resultset&#39; );
    my $resultset = $c-&gt;schema-&gt;resultset( $resultset_class );
    $c-&gt;render(
        resultset =&gt; $resultset,
    );
}
</code></pre>

<p>So, to make sure I don&#39;t call <code>render</code> too early, and to make sure
subclasses can use the data from my superclass, I instead put all the
data directly in to the stash with the <a href="https://mojolicious.org/perldoc/Mojolicious/Controller#stash"><code>stash()</code>
method</a>.</p>

<p>Remember that <code>$c-&gt;render( %stash );</code> is the same as <code>$c-&gt;stash( %stash
); $c-&gt;render();</code>. And, if we never call <code>render()</code> ourselves, that&#39;s
okay, as Mojolicious will call it for us (unless we call
<a href="https://mojolicious.org/perldoc/Mojolicious/Controller#render_later"><code>render_later</code></a>,
which we won&#39;t).</p>

<pre><code># This method can be used by a subclass, which can get
# the ResultSet object out of the stash
sub list {
    my ( $c ) = @_;
    my $resultset_class = $c-&gt;stash( &#39;resultset&#39; );
    my $resultset = $c-&gt;schema-&gt;resultset( $resultset_class );
    $c-&gt;stash(
        resultset =&gt; $resultset,
    );
}
</code></pre>

<h1>Return True to Continue</h1>

<p>Since there are times where we do want to render a response in the
superclass (in the case of a 404 not found error, for example), we need
to be able to tell our caller that we did.</p>

<pre><code># How can I tell that a 404 error is already rendered?
sub get {
    my ( $c ) = @_;
    my $resultset_class = $c-&gt;stash( &#39;resultset&#39; );
    my $id = $c-&gt;stash( &#39;id&#39; );
    my $resultset = $c-&gt;schema-&gt;resultset( $resultset_class );
    my $row = $resultset-&gt;find( $id );
    if ( !$row ) {
        $c-&gt;reply-&gt;not_found();
    }
    else {
        $c-&gt;stash(
            row =&gt; $row,
        );
    }
}
</code></pre>

<p>We can do so with a simple convention: Return true to continue the
dispatch, and return false to stop. This is the same as <a href="https://mojolicious.org/perldoc/Mojolicious/Guides/Routing#Under"><code>under</code> route
callbacks</a>.
Since we&#39;re returning, we can also simplify the code a little bit to
remove the need for the <code>else</code> block:</p>

<pre><code>sub get {
    my ( $c ) = @_;
    my $resultset_class = $c-&gt;stash( &#39;resultset&#39; );
    my $id = $c-&gt;stash( &#39;id&#39; );
    my $resultset = $c-&gt;schema-&gt;resultset( $resultset_class );
    my $row = $resultset-&gt;find( $id );
    if ( !$row ) {
        $c-&gt;reply-&gt;not_found();
        # stop dispatch
        return;
    }
    # continue dispatch
    return $c-&gt;stash(
        row =&gt; $row,
    );
}
</code></pre>

<h1>Inheritance</h1>

<p>With our superclass controller ready, I can now write a subclass. I have
a section of my site that&#39;s dedicated to user content, so I&#39;ll filter
the <code>list</code> ResultSet to only those results for the current user, and
make sure that <code>get</code> only returns content for the current user
(displaying a &quot;not found&quot; response if it&#39;s the wrong user).</p>

<p>Remember our superclass method will return true if we&#39;re okay to
continue working. So, we need to check the return value.</p>

<pre><code>package My::Controller::DBIC::UserContent;
use Mojo::Base &#39;My::Controller::DBIC&#39;;
sub list {
    my ( $c ) = @_;
    $c-&gt;SUPER::list || return;
    my $rs = $c-&gt;stash( &#39;resultset&#39; );
    $rs = $rs-&gt;search( { user_id =&gt; $c-&gt;current_user-&gt;id } );
    $c-&gt;stash( resultset =&gt; $rs );
}
sub get {
    my ( $c ) = @_;
    $c-&gt;SUPER::get || return;
    my $row = $c-&gt;stash( &#39;row&#39; );
    if ( $row-&gt;user_id ne $c-&gt;current_user-&gt;id ) {
        $c-&gt;reply-&gt;not_found;
        return;
    }
}
</code></pre>

<p>With reusable controllers, we can greatly reduce the amount of code we
need to write. Less code means fewer bugs and more time spent writing
new features and doing useful things!</p>


                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/development/">development</a>
                        <a href="https://mojolicious.io/blog/tag/controller/">controller</a>
                        <a href="https://mojolicious.io/blog/tag/dbix-class/">DBIx::Class</a>
                    </p>

            ]]></description>
            <pubDate>
                Mon, 28 Jan 2019 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Writing Reusable Controllers</title>
            <link>https://mojolicious.io/blog/2019/01/21/writing-reusable-controllers/</link>
            <guid>https://mojolicious.io/blog/2019/01/21/writing-reusable-controllers/</guid>
            <description><![CDATA[
                <p>In all the web applications I&#39;ve written with
<a href="http://mojolicious.org">Mojolicious</a>, one of the most mis-used features
are controllers. Mojolicious is
a <a href="https://mojolicious.org/perldoc/Mojolicious/Guides/Growing#Model-View-Controller">Model-View-Controller</a>
framework, and the MVC pattern is intended to provide for code re-use.</p>

<p>Models can be interchangeable and used by the same controllers and
templates. With a common, consistent model API, the right controller can
list any data, update any data. If all of our models have a method named
&quot;search&quot;, I can make a single controller method that will run a search
on any of them.</p>

<p>The easiest way to demonstrate this is with
<a href="http://metacpan.org/pod/DBIx::Class">DBIx::Class</a>. DBIx::Class provides
a consistent API for a relational database. </p>

<h2>The Problem</h2>

<p>For this example, I&#39;ll use <a href="https://github.com/preaction/Mojolicious-Plugin-DBIC/tree/master/t/lib/Local">this DBIx::Class
schema</a>.
My schema has a couple tables: <code>notes</code> for storing simple notes, and
<code>events</code> for storing calendar events.</p>

<p>In order to work with my data, I need to write some controller methods:</p>

<pre><code>package MyApp::Controller::Notes;
sub list {
    my ( $c ) = @_;
    my $resultset = $c-&gt;schema-&gt;resultset( &#39;Notes&#39; );
    $c-&gt;render(
        template =&gt; &#39;notes/list&#39;,
        resultset =&gt; $resultset,
    );
}

package MyApp::Controller::Events;
sub list {
    my ( $c ) = @_;
    my $resultset = $c-&gt;schema-&gt;resultset( &#39;Events&#39; );
    $c-&gt;render(
        template =&gt; &#39;events/list&#39;,
        resultset =&gt; $resultset,
    );
}
</code></pre>

<p>Well, that&#39;s less-than-ideal: I&#39;ve just copy/pasted the same code and
changed a few words. And now I need to do the same for looking at
individual notes/events, creating, updating, and deleting.</p>

<p>Copy/pasting code is tedious and makes code harder to maintain. It would
be much nicer if we could write one controller and just configure it to
use our different tables!</p>

<h2>The Stash</h2>

<p>The way to configure controllers is through the <a href="https://mojolicious.org/perldoc/Mojolicious/Guides/Tutorial#Stash-and-templates">Mojolicious
stash</a>,
the data store for a request. When setting up a route, I can add stash
values that will be used by my controller. This includes the &quot;reserved&quot;
stash values like &quot;template&quot; which tells Mojolicious what template to
render by default.</p>

<p>If, instead of above, I write a controller method that looks in the
stash for its configuration, I can reuse it by changing those stash
values.</p>

<pre><code>package MyApp::Controller::DBIC;
sub list {
    my ( $c ) = @_;
    my $resultset_class = $c-&gt;stash( &#39;resultset&#39; );
    my $resultset = $c-&gt;schema-&gt;resultset( $resultset_class );
    $c-&gt;render(
        resultset =&gt; $resultset,
    );
}
</code></pre>

<p>Now I&#39;ve got a &quot;list&quot; method that accepts a ResultSet class in the
<code>resultset</code> stash. </p>

<p>Then I can configure a route (<code>/notes</code>) which will route to the DBIC
controller I&#39;ve created and the <code>list</code> method inside it to list the
Resultset I tell it to with the template I give it:</p>

<pre><code>use Mojolicious::Lite;
use Local::Schema;
my $dsn = &#39;dbi:SQLite:data.db&#39;;
# Controller will use this to get our schema
helper schema =&gt; Local::Schema-&gt;connect( $dsn );
# List all our notes
get &#39;/notes&#39; =&gt; {
    controller =&gt; &#39;DBIC&#39;,
    action =&gt; &#39;list&#39;,
    resultset =&gt; &#39;Notes&#39;,
    template =&gt; &#39;notes/list&#39;,
} =&gt; &#39;notes.list&#39;;
app-&gt;start;
__DATA__
@@ notes/list.html.ep
&lt;ul&gt;&lt;% for my $row ( $resultset-&gt;all ) { %&gt;
    &lt;li&gt;&lt;%= $row-&gt;title %&gt;&lt;/li&gt;
&lt;% } %&gt;&lt;/ul&gt;
</code></pre>

<h2>Route Placeholders</h2>

<p>That&#39;s all fine and good for simple tasks like listing all the things,
but what about when there&#39;s a variable involved, like looking up items
by their ID? Again, we just need a little configuration, this time the
row&#39;s ID:</p>

<pre><code>package MyApp::Controller::DBIC;
sub get {
    my ( $c ) = @_;
    my $resultset_class = $c-&gt;stash( &#39;resultset&#39; );
    my $id = $c-&gt;stash( &#39;id&#39; );
    my $resultset = $c-&gt;schema-&gt;resultset( $resultset_class );
    my $row = $resultset-&gt;find( $id );
    $c-&gt;render(
        row =&gt; $row,
    );
}
</code></pre>

<p>Now, since route placeholders are put into the stash, I can use them to
configure my controller as well. So, when a user visits <code>/notes/34</code>,
they will see the note with an ID of &#39;34&#39;:</p>

<pre><code># ...
get &#39;/notes/:id&#39; =&gt; {
    controller =&gt; &#39;DBIC&#39;,
    action =&gt; &#39;get&#39;,
    resultset =&gt; &#39;Notes&#39;,
    template =&gt; &#39;notes/get&#39;,
} =&gt; &#39;notes.get&#39;;
# ...
__DATA__
@@ notes/get.html.ep
% title $row-&gt;title;
&lt;h1&gt;&lt;%= $row-&gt;title %&gt;&lt;/h1&gt;
%== $row-&gt;description
</code></pre>

<p>With this new named route, I can display the saved note.</p>

<p><em>Note</em>: By exposing the stash to the URL, users can type in any ID they
want. So, if you have data you don&#39;t want users to see, make sure to
protect it!</p>

<h2>... And more</h2>

<p>I can continue doing this for &quot;create&quot;, &quot;update&quot;, and &quot;delete&quot; actions
as well, making an application much easier to assemble: Most of my code
will (rightly) be in my model classes and my templates.</p>

<p>I can also add more features to my &quot;DBIC&quot; controller:</p>

<ul>
<li>Stash values to set <a href="https://metacpan.org/pod/DBIx::Class::ResultSet#search">ResultSet <code>search()</code> condition and options
hashes</a>.</li>
<li>Expose search columns and options to query parameters, safely</li>
<li>Add JSON API responses using <a href="https://mojolicious.org/perldoc/Mojolicious/Plugin/DefaultHelpers#respond_to">the <code>respond_to</code>
helper</a></li>
<li>Pagination on the <code>list</code> method</li>
</ul>

<p>Once the features are added once, every route can take advantage of
them.</p>

<p>Since there&#39;s little point in multiple copies of the exact same &quot;DBIC&quot;
controller, I wrote one and released it to CPAN as
<a href="http://metacpan.org/pod/Mojolicious::Plugin::DBIC">Mojolicious::Plugin::DBIC</a>.
The <a href="https://github.com/preaction/Mojolicious-Plugin-DBIC/tree/master/eg">code for this example is available on
Github</a>.</p>

<p>If DBIx::Class isn&#39;t your model layer, or even if it is,
<a href="http://preaction.me/yancy">Yancy</a> provides <a href="http://preaction.me/yancy/perldoc/Yancy/Controller/Yancy">configurable
controllers</a>
like this, along with an <a href="http://preaction.me/yancy/perldoc/#DESCRIPTION">app to edit
content</a>.</p>


                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/development/">development</a>
                        <a href="https://mojolicious.io/blog/tag/controller/">controller</a>
                        <a href="https://mojolicious.io/blog/tag/dbix-class/">DBIx::Class</a>
                    </p>

            ]]></description>
            <pubDate>
                Mon, 21 Jan 2019 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 25: Special Thanks</title>
            <link>https://mojolicious.io/blog/2018/12/25/special-thanks/</link>
            <guid>https://mojolicious.io/blog/2018/12/25/special-thanks/</guid>
            <description><![CDATA[
                <p>This advent calendar, I have special thanks to offer to all the people who helped make it possible.
I&#39;ll list them shortly, but before I do, I&#39;d like to introduce you to the newest unofficial member of the Mojolicious Core Team: Jude Carl Berger!
Jude was born on the first day of this calendar, December 1st, at 2:15 am Chicago time.
If you&#39;re looking at timestamps, yes, that&#39;s about 4 hours after the first blog post went live.</p>

<p>After a one week stay in the NICU for a relatively minor condition, he&#39;s now home with myself and his mother, my wonderful wife Carolyn, who I have to thank first.
Not too many partners would put up with someone flitting out to edit a blog post or hit &quot;publish&quot; at the right moment during this time in our lives.
And thanks for Jude.</p>

<p>Armed with that knowledge, you can surely see that even more than usual I couldn&#39;t have done this without help!
So, with no further ado, I want to thank all the authors,</p>

<ul>
<li>Boyd Duffee</li>
<li>brian d foy</li>
<li>Chris Seigman</li>
<li>Doug Bell</li>
<li>Jason Crome</li>
<li>Joe Cooper</li>
<li>Luc Didry</li>
<li>Sachin Dangol</li>
<li>Shawn Sorichetti</li>
</ul>

<p>I especially want to note that Doug Bell went above and beyond with eight (!) articles, brian d foy did more than his fair share with four, and Luc Didry and Boyd Duffee did two each!
I also want to specially mention Jason Crome who, during a tough month of his own, administered the <a href="http://advent.perldancer.org/2018">Twelve Days of Dancer</a> and contributed a cross-over article to ours as well.
The calendar is obviously nothing without the articles and so I&#39;m tremendously thankful that I had authors that I could lean on to help me when I wasn&#39;t able to fill extra space as I might have in other years.
Spectacular work, one and all!</p>

<p>We intend to publish more on this site throughout the year, including some pieces from two authors who submitted articles after all the days had been filled.
Articles had been committed to the repo, but were not yet published, which led to a small confusion in which these authors rose to meet a need they thought existed, so thank you Stefan Adams and Yuki Kimoto for stepping up!
We&#39;ll get those and other articles out to you in the coming months!</p>

<p>I want to thank Doug again for creating and maintaining <a href="http://preaction.me/statocles/">Statocles</a>, the static blog engine that powers this site.
I want to thank my employer <a href="https://www.servercentral.com/">ServerCentral</a> who not only are great to work for and support open source, but who gave me lots of time to get settled in with the newest member of my family (and a few cute gifts for him too).
I want to thank Sebastian Riedel for writing Mojolicious and for the outfit you see on Jude in the picture above (as far as I know, it is a unique piece), and the entire Mojolicious Core Team and community.</p>

<p>I want to thank Jude for being a reasonably happy newborn and sleeping for longer-than-average stretches at night.</p>

<p>Finally, I extend my warmest thanks to the doctors, nurses and staff of Northwest Community Hospital in Arlington Heights, Illinois and especially the NICU nurses who are beyond amazing.</p>

<p>Merry Christmas, Happy Holidays, Happy New Year, and Happy Perling!</p>


                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                    </p>

            ]]></description>
            <pubDate>
                Tue, 25 Dec 2018 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 24: Async/Await the Mojo Way</title>
            <link>https://mojolicious.io/blog/2018/12/24/async-await-the-mojo-way/</link>
            <guid>https://mojolicious.io/blog/2018/12/24/async-await-the-mojo-way/</guid>
            <description><![CDATA[
                <h2>The Problems with Thinking in Asynchronous Code</h2>

<p>I&#39;ve thought a lot about asynchronous code.
Learning it, writing it, teaching it.
Async is hard.</p>

<blockquote>
  <p>Learning async programming is about being completely confused and overcomplicating everything and eventually having an &#39;aha&#39; moment and then being utterly frustrated you don&#39;t have a way to teach other people without them needing to go through the same process.
  <cite><a href="https://shadow.cat/blog/matt-s-trout/">Matt S. Trout</a></cite></p>
</blockquote>

<p>While Matt is right, I&#39;ve thought a lot about that quote and I think I&#39;ve come up with an underlying problem.
This may sound trite and it may seem obvious, but the problem is that writing asynchronous code is just fundamentally different than writing blocking code.</p>

<p>We&#39;ve always known how to make one instruction follow another, that&#39;s easy, it happens on the next line of code.
Line one executes and then line two.
If line two needs something from line one it will be there.</p>

<p>Say you want to write &quot;get this web resource, then print the title&quot;.
In blocking code that is easy!</p>

<pre><code>use Mojo::Base -strict, -signatures;
use Mojo::UserAgent;
use Mojo::Util &#39;trim&#39;;
my $ua = Mojo::UserAgent-&gt;new;

my $title = trim $ua-&gt;get($url)-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
say $title;
</code></pre>

<p>In asynchronous code, those two steps don&#39;t just follow in sequence, either in execution in the file nor in actual code flow.
A newcomer to nonblocking is told that to make that nonblocking, you need a callback; a thing to do once the transaction is complete.
So they might write this (non-working!) code instead.</p>

<pre><code>use Mojo::Base -strict, -signatures;
use Mojo::IOLoop;
use Mojo::UserAgent;
use Mojo::Util &#39;trim&#39;;
my $ua = Mojo::UserAgent-&gt;new;
my $url = &#39;https://mojolicious.org&#39;;

my $title;
$ua-&gt;get($url, sub ($ua, $tx) {
  $title = trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
});
say $title;

Mojo::IOLoop-&gt;start;
</code></pre>

<p>The problem of course is, the print statement happens before the title is extracted.
In fact the print statement happens before the request is even made!</p>

<p><em>Because there are a lot of examples, I&#39;ll skip the first chunk of code.
Assume those lines are always there going foward.</em></p>

<p>The fix in this case is easy</p>

<pre><code>$ua-&gt;get($url, sub ($ua, $tx) {
  my $title = trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
  say $title;
});
Mojo::IOLoop-&gt;start;
</code></pre>

<p>but that isn&#39;t always the case.
What if you wanted to return the title rather than print it?
What if wanted to fetch two resources rather than one, whether sequentially or in parallel?</p>

<h2>An Important First Step</h2>

<p>Several attempts have been made to organize and improve this situation.
The pattern that seems to have emerged as the preferred choice is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">Promises</a>.</p>

<p>Promises have a nice property that gets them closer to linear code.
You create and return a promise object that represents the eventual result of the task, though the task itself may not have even started yet.
In our example before we could say</p>

<pre><code>use Mojo::Promise;

my $promise = Mojo::Promise-&gt;new;
$ua-&gt;get($url, sub ($ua, $tx) {
  my $title = trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
  $promise-&gt;resolve($title);
});

$promise-&gt;then(sub ($title) {
  say $title;
})-&gt;wait;
</code></pre>

<p>At first glance this isn&#39;t too much better than the callback.
However, a few nice features emerge.
The most important of which is that the promise object can be returned to the caller and the caller can choose what to do with it.</p>

<p>In useful code you would also want to attach error handling, though I&#39;ve omitted it here for bevity.
Mojolicious&#39; promise implementation also gives us the <code>wait</code> method to start the ioloop if necessary.</p>

<p>Although it is interesting to see how a user can create a promise object to convert a callback api to promises, many libraries, including Mojolicious, now have promise variants built-in.
Rather than depending on the user to create a promise to resolve in the callback, these libraries will just return a promise of their own.
In the Mojolicious project, by convention methods that return promises end in <code>_p</code>.</p>

<p>With that we can write similar code to the one above</p>

<pre><code>my $promise = $ua-&gt;get_p($url);

$promise-&gt;then(sub ($tx) {
  my $title = trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
  say $title;
})-&gt;wait;
</code></pre>

<p>However that&#39;s slightly different.
The promise above resolved with the title, this one resolves with the transaction.
That brings us to the next interesting feature of promises: the return value of <code>then</code> is another promise that is resolved with the return value of the callback.
Additionally, if that value is another promise then they chain, if not then it resolves with the value.</p>

<p>We can use that property to replicate the original promise example above more directly like this</p>

<pre><code>my $promise = $ua-&gt;get_p($url)-&gt;then(sub ($tx) {
  return trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
});

$promise-&gt;then(sub ($title) {
  say $title;
})-&gt;wait;
</code></pre>

<p>This is important if say you had a function that was intended to return a promise that resolved to a title.
Perhaps you might have a function called <code>get_title_p</code> that needs to be called from elsewhere in your project.
Rather than relying on the promise that the user-agent returned, you can now post-process and return the title rather than the HTTP response.</p>

<pre><code>sub get_title_p ($url) {
  my $promise = $ua-&gt;get_p($url)-&gt;then(sub ($tx) {
    return trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
  });
  return $promise;
}

get_title_p($url)-&gt;then(sub ($title) {
  say $title;
})-&gt;wait;
</code></pre>

<p>All told, this is a step in the right direction, but it still involves a mental shift in style.
Even if this is easier than using pure callbacks, you still have to keep track of promises, consider the implications of chaining.
You still have to attach callbacks using <code>then</code>.
And don&#39;t forget error handling callbacks too!</p>

<p><em>Editor&#39;s note: to this point in the article, it is similar to the Perl Advent Calendar entry <a href="http://www.perladvent.org/2018/2018-12-19.html">posted just a few days before this one on 2018-12-19</a>, humorously presented by Mark Fowler.
If you&#39;d like to see another take on promises and Mojo::Promise specifically, give it a read.
Everything in it is applicable even as this article takes it one step further below ...</em></p>

<h2>Async/Await</h2>

<p>What we really wish we could tell the Perl interpreter to do is</p>

<ul>
<li>suspend execution until this promise resolves or is rejected</li>
<li>then move on to handle tasks</li>
<li>when it eventually does resolve or reject</li>
<li>then resume processing right here or throw an exception</li>
</ul>

<p>It is a big ask, but if you could say that, you&#39;d basically get linearity back.
Promises give us the control we&#39;d need for such a mechanism, but until now we in Perl-land lack the ability to suspend and resume the interpreter.
Indeed, some languages already have this mechanism and the result is called the Async/Await pattern.
With a little added magic, howver, we can do just that.</p>

<p>That was a lot of introduction, but now I&#39;m finally ready to introduce <a href="https://metacpan.org/pod/Mojo::AsyncAwait">Mojo::AsyncAwait</a>!</p>

<pre><code>use Mojo::AsyncAwait;

async get_title_p =&gt; sub ($url) {
  my $tx = await $ua-&gt;get_p($url);
  return trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
};

get_title_p($url)-&gt;then(sub ($title) {
  say $title;
})-&gt;wait;
</code></pre>

<p>This code behaves exactly the same as before, but there are some noticable differences.
First we declared <code>get_title_p</code> using the <code>async</code> keyword.
For our purposes this means two things: the function can use the <code>await</code> keyword and it must return a promise.
Of course right away you&#39;ll see that I don&#39;t return a promise from that function.
Don&#39;t worry, it gets wrapped in one automatically if needed.</p>

<p>And what is that <code>await</code> keyword?
That keyword is the magic suspend/resume that we had hoped for above.
It receives a promise (or a value, which is automatically wrapped in a promise), and tells Perl that it can move on to other things until that promise is resolved or rejected.
When it is the code extracts the value, in this case the transaction, and the execution continues as if it were blocking code!</p>

<p>Now we wish we could do the same when calling <code>get_title_p</code>.
Never fear, just wrap it in an async function too, let&#39;s call it <code>main</code>.</p>

<pre><code>use Mojo::AsyncAwait;

async get_title_p =&gt; sub ($url) {
  my $tx = await $ua-&gt;get_p($url);
  return trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
};

async main =&gt; sub {
  my $title = await get_title_p($url);
  say $title;
};

main()-&gt;wait;
</code></pre>

<p>Of course, if we didn&#39;t need the intermediary function anymore, we could skip it.
After all, the first example didn&#39;t have <code>get_title_p</code>, it just fetched the url, extracted the title, and printed it.</p>

<pre><code>use Mojo::AsyncAwait;

async main =&gt; sub {
  my $tx = await $ua-&gt;get_p($url);
  my $title = trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
  say $title;
};

main()-&gt;wait;
</code></pre>

<p>And now that&#39;s what we&#39;ve done too!</p>

<h2>Real World Use</h2>

<p>The above examples were neat, but since they only fetch one url there&#39;s no reason to be async.
Let&#39;s look at a few quick useful examples where async is a benefit.</p>

<h3>Concurrent Requests</h3>

<p>The first case might be to extend our example to fetching multiple urls concurrently.
We can get the promises returned by calling <code>get_title_p</code> on each url, then await a new promise that represents all of them.
We use <code>map</code> to take the first (only) resolve value from the result of each promise in <code>all</code>.</p>

<pre><code>use Mojo::AsyncAwait;
use Mojo::Promise;

async get_title_p =&gt; sub ($url) {
  my $tx = await $ua-&gt;get_p($url);
  return trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
};

async main =&gt; sub (@urls) {
  my @promises = map { get_title_p($_) } @urls;
  my @titles = await Mojo::Promise-&gt;all(@promises);
  say for map { $_-&gt;[0] } @titles;
};

my @urls = (qw(
  https://mojolicious.org
  https://mojolicious.io
  https://metacpan.org
));
main(@urls)-&gt;wait;
</code></pre>

<p>Were this code written sequentially, the time it would take to run would be the sum of the time to fetch each url.
However, as written, this will run in approximately the time it takes for the slowest url to respond.</p>

<h3>Web Apps</h3>

<p>Now let&#39;s say you wanted to turn that script into a web API.
If we had a webapp that accepted urls as query parameters and returned the responses as JSON it might look like this</p>

<pre><code>use Mojolicious::Lite -signatures;
use Mojo::AsyncAwait;
use Mojo::Promise;
use Mojo::Util &#39;trim&#39;;

plugin &#39;PromiseActions&#39;;

helper get_title_p =&gt; async sub ($c, $url) {
  my $tx = await $c-&gt;ua-&gt;get_p($url);
  return trim $tx-&gt;res-&gt;dom-&gt;at(&#39;title&#39;)-&gt;text;
};

any &#39;/&#39; =&gt; async sub ($c) {
  my $urls = $c-&gt;every_param(&#39;url&#39;);
  my @promises = map { $c-&gt;get_title_p($_) } @$urls;
  my @titles = await Mojo::Promise-&gt;all(@promises);
  $c-&gt;render(json =&gt; [ map { $_-&gt;[0] } @titles ]);
};

app-&gt;start;
</code></pre>

<p>Where the example above would be at</p>

<pre><code>localhost:3000?url=https%3A%2F%2Fmojolicious.org&amp;url=https%3A%2F%2Fmojolicious.io&amp;url=https%3A%2F%2Fmetacpan.org
</code></pre>

<p>That code is almost exactly what you&#39;d write for a blocking implementation except that it would block the server and it have to fetch the urls sequentially.
Instead, since it is written nonblocking, the requests are all made concurrently and the server is still free to respond to new clients.
And yet the code is still very easy to follow.</p>

<p>Note: the <a href="https://metacpan.org/pod/Mojolicious::Plugin::PromiseActions">PromiseActions</a> plugin automatically attaches error handlers to the controller action when it returns a promise; it is highly recommended when using async actions.</p>

<h2>A Word on Implementation</h2>

<p>As stated before Mojo::AsyncAwait requires some mechanism to suspend the interpreter and resume it at that point later on.
Currently, the module uses the somewhat controversial module <a href="https://metacpan.org/pod/Coro">Coro</a> to do it.
As a bulwark against future implimentation changes, it comes with a pluggable backend system, not unlike how Mojo::IOLoop&#39;s pluggable reactor system works.
The default implementation may change and users may choose to use any available backend if they have a preference (once new ones come along, and others  <strong>are</strong> in the works).</p>

<h2>Conclusion</h2>

<p>So now the formula is simple.</p>

<ul>
<li>Use libraries that return promises rather than take callbacks.</li>
<li>Use the <code>async</code> keyword when declaring functions that need to <code>await</code> promises.</li>
<li>Organize your promises using <a href="https://mojolicious.org/perldoc/Mojo/Promise#all">all</a>, <a href="https://mojolicious.org/perldoc/Mojo/Promise#race">race</a> (only wait for the first resolved promise) or some <a href="https://mojolicious.io/blog/2018/12/03/higher-order-promises/">higher order promise</a> when needed.</li>
</ul>

<p>Hopefully with Mojo::AsyncAwait, writing asynchronous code is finally going to be accessible to those users that haven&#39;t yet had Matt&#39;s &quot;aha&quot; moment.
And for those of us who have, don&#39;t worry, you&#39;ll love it too.</p>

<p><em>Another excellent resource is <a href="https://www.youtube.com/watch?v=gB-OmN1egV8">The Evolution of Async JavaScript: From Callbacks, to Promises, to Async/Await</a> by Tyler McGinnis.
It is for JavaScript, but nearly everything applies except they syntax.
Highly recommended.</em></p>


                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/non-blocking/">non-blocking</a>
                    </p>

            ]]></description>
            <pubDate>
                Mon, 24 Dec 2018 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 23: Mojolicious and Angular</title>
            <link>https://mojolicious.io/blog/2018/12/23/mojolicious-and-angular/</link>
            <guid>https://mojolicious.io/blog/2018/12/23/mojolicious-and-angular/</guid>
            <description><![CDATA[
                <p><a href="https://angular.io/">Angular</a> is one of the most popular front-end web application frameworks, helping you build modern applications for the web, mobile, or desktop.
<a href="https://mojolicious.org/">Mojolicious</a> is a next generation web framework for the Perl programming language.
Mojolicious and Angular together can certainly build a next generation web application.</p>

<p>At work, we have been using these two to build a very responsive, scalable and fantastic web apps.
Mojolicious as a backend gives a lot of fun to work stuffs like <a href="https://mojolicious.org/perldoc/Minion">Minion</a>, <a href="https://mojolicious.org/perldoc/Mojo/DOM">Mojo::DOM</a>, <a href="https://mojolicious.org/perldoc/Test/Mojo">Test::Mojo</a>.
It has many plugins, including easy implementation of <a href="https://metacpan.org/pod/Mojolicious::Plugin::OpenAPI">OpenAPI</a>, <a href="https://metacpan.org/pod/Mojolicious::Plugin::OAuth2">OAuth</a>, utility modules and of many others on CPAN.</p>

<p>One of the reasons you want to have this kind of web development set up is that front-end Angular developers and backend Mojolicious developers can work independently.</p>

<p>Angular is backend agnostic. Node.js Express is often used as backend for Angular, but we love Perl and Mojolicious.</p>

<p>We will see how these two can be married to make a web application today.</p>

                    <p><a href="https://mojolicious.io/blog/2018/12/23/mojolicious-and-angular/#section-2">Continue reading...</a></p>

                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/angular/">Angular</a>
                        <a href="https://mojolicious.io/blog/tag/javascript/">JavaScript</a>
                    </p>

            ]]></description>
            <pubDate>
                Sun, 23 Dec 2018 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

