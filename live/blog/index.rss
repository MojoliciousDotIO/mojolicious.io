<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>mojolicious.io</title>
        <link>https://mojolicious.io/blog/</link>
        <atom:link href="https://mojolicious.io/blog/index.rss" rel="self" type="application/rss+xml" />
        <description>Blog feed of mojolicious.io</description>
        <generator>Statocles 0.087</generator>
        <item>
            <title>Day 8: Mocking a REST API</title>
            <link>https://mojolicious.io/blog/2017/12/08/day-8-mocking-a-rest-api/</link>
            <guid>https://mojolicious.io/blog/2017/12/08/day-8-mocking-a-rest-api/</guid>
            <description><![CDATA[
                <p>One of my applications is a pure-JavaScript UI for a JSON API. This UI
is an entirely different project that communicates with a public API
using an OpenAPI specification.</p>

<p>Our public API is huge and complex: To set up the public API, I need
a database, sample data, and three other private API servers that
perform individual tasks as directed by the public API. Worse, I would
need to set up a lot of different test scenarios with different kinds of
data.</p>

<p>It would be a lot easier to set up a mock public API that I could use to
test my UI, and it turns out that Mojolicious makes this very easy.</p>

<p>So let&#39;s set up a simple Mojolicious::Lite app that responds to a path
with a JSON response:</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
get &#39;<span class="hljs-string">/servers</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        json =&gt; [
            { ip =&gt; &#39;<span class="hljs-string">10.0.0.1</span>&#39;, os =&gt; &#39;<span class="hljs-string">Debian 9</span>&#39; },
            { ip =&gt; &#39;<span class="hljs-string">10.0.0.2</span>&#39;, os =&gt; &#39;<span class="hljs-string">Debian 8</span>&#39; }
        ],
    );
};
app-&gt;start;
</code></pre>

<p>Now I can fetch that JSON response by starting the web application and
going to <code>/servers</code> or by using the <code>get</code> command:</p>

<pre><code>$ perl test-api.pl get /servers
[{&quot;ip&quot;:&quot;10.0.0.1&quot;,&quot;os&quot;:&quot;Debian 9&quot;},{&quot;ip&quot;:&quot;10.0.0.2&quot;,&quot;os&quot;:&quot;Debian 8&quot;}

$ perl test-api.pl daemon
Server available at http://127.0.0.1:3000
</code></pre>

<p>That&#39;s pretty easy and shows how easy Mojolicious can be to get started.
But I have dozens of routes in my application! Combined with all the
possible data and its thousands of routes. How do I make all of them
work without copy-pasting code for every single route?</p>

<p>Let&#39;s match the whole path of the route and then create a template with
the given path. Mojolicious lets us match the whole path using the <code>*</code>
placeholder in the route path. Then we can use that path to look up the
template, which we&#39;ll put in the <code>__DATA__</code> section.</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ),
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ servers.json.ep
[
    { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; },
    { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
]
</code></pre>

<p>Again, we can use the <code>get</code> command to test that we get the right data:</p>

<pre><code>$ perl test-api.pl get /servers
[
    { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; },
    { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
]
</code></pre>

<p>So now I can write a bunch of JSON in my script and it will be exposed
as an API. But I&#39;d like it to be easier to make lists of things: REST
APIs often have one endpoint as a list and another as an individual item
in that list. We can make a list by composing our individual parts using
Mojolicious templates and the <code>include</code> template helper:</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ),
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ servers.json.ep
[
    &lt;%== include &#39;servers/1&#39; %&gt;,
    &lt;%== include &#39;servers/2&#39; %&gt;
]
@@ servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
</code></pre>

<p>Now I can test the list endpoint again:</p>

<pre><code>$ perl test-api.pl get /servers
[
    { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
,
    { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
]
</code></pre>

<p>And also one of the individual item endpoints:</p>

<pre><code>$ perl test-api.pl get /servers/1
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
</code></pre>

<p>Currently we handle all request methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>)
the same, but my API doesn&#39;t work like that. So, I need to be able to
provide different data for different request methods. To do that, let&#39;s add the
request method to the template path:</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-function">join</span>( &#39;<span class="hljs-string">/</span>&#39;, <span class="hljs-function">uc</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span>, <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ) ),
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ GET/servers.json.ep
[
    &lt;%== include &#39;GET/servers/1&#39; %&gt;,
    &lt;%== include &#39;GET/servers/2&#39; %&gt;
]
@@ GET/servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ GET/servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
@@ POST/servers.json.ep
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: &lt;%== $c-&gt;req-&gt;body %&gt; }
</code></pre>

<p>Now all our template paths start with the HTTP request method (<code>GET</code>),
allowing us to add different routes for <code>POST</code> requests and other HTTP
methods.</p>

<p>We also added a <code>POST/servers.json.ep</code> template that shows us getting
a successful response from adding a new server via the API. It even
correctly gives us back the data we submitted, like our original API
might do.</p>

<p>We can test our added <code>POST /servers</code> method with the <code>get</code> command
again:</p>

<pre><code>$ perl test-api.pl get -M POST -c &#39;{ &quot;ip&quot;: &quot;10.0.0.3&quot; }&#39; /servers
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: { &quot;ip&quot;: &quot;10.0.0.3&quot; } }
</code></pre>

<p>Now what if I want to test what happens when the API gives me an error?
Mojolicious has an easy way to layer on additional templates to use for
certain routes: <a href="http://mojolicious.org/perldoc/Mojolicious/Guides/Rendering#Template-variants">Template
variants</a>.
These variant templates will be used instead of the original template,
but only if they are available. Read more on <a href="https://mojolicious.io/blog/2017/12/07/day-7-using-template-variants-for-a-beta-landing-page/">how to use template
variants yesterday on the advent
calendar</a>.</p>

<p>By setting the template variant to the application &quot;mode&quot;, we can easily
switch between multiple sets of templates by adding <code>-m &lt;mode&gt;</code> to the
command we run.</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-function">join</span>( &#39;<span class="hljs-string">/</span>&#39;, <span class="hljs-function">uc</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span>, <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ) ),
        variant =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">app</span>-&gt;<span class="hljs-type">mode</span>,
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ GET/servers.json.ep
[
    &lt;%== include &#39;GET/servers/1&#39; %&gt;,
    &lt;%== include &#39;GET/servers/2&#39; %&gt;
]
@@ GET/servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ GET/servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
@@ POST/servers.json.ep
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: &lt;%== $c-&gt;req-&gt;body %&gt; }
@@ POST/servers.json+error.ep
% $c-&gt;res-&gt;code( 400 );
{ &quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;Bad request&quot; }
</code></pre>

<pre><code>$ perl test-api.pl get -m error -M POST -c &#39;{}&#39; /servers
{ &quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;Bad request&quot; }
</code></pre>

<p>And finally, since I&#39;m using this to test an AJAX web application,
I need to allow the preflight <code>OPTIONS</code> request to succeed and I need to
make sure that all of the correct <code>Access-Control-*</code> headers are set
to allow for cross-origin requests.</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
hook after_build_tx =&gt; <span class="hljs-keyword">sub </span>{
<span class="hljs-keyword">my</span> (<span class="hljs-type">$tx</span>, <span class="hljs-type">$app</span>) = <span class="hljs-type">@_</span>;
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Allow-Origin</span>&#39; =&gt; &#39;<span class="hljs-string">*</span>&#39; );
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Allow-Methods</span>&#39; =&gt; &#39;<span class="hljs-string">GET, POST, PUT, PATCH, DELETE, OPTIONS</span>&#39; );
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Max-Age</span>&#39; =&gt; <span class="hljs-number">3600</span> );
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Allow-Headers</span>&#39; =&gt; &#39;<span class="hljs-string">Content-Type, Authorization, X-Requested-With</span>&#39; );
};
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-comment"># Allow preflight OPTIONS request for XmlHttpRequest to succeed</span><span class="hljs-comment">
</span>    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">rendered</span>( <span class="hljs-number">204</span> ) <span class="hljs-keyword">if</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span> eq &#39;<span class="hljs-string">OPTIONS</span>&#39;;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-function">join</span>( &#39;<span class="hljs-string">/</span>&#39;, <span class="hljs-function">uc</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span>, <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ) ),
        variant =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">app</span>-&gt;<span class="hljs-type">mode</span>,
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ GET/servers.json.ep
[
    &lt;%== include &#39;GET/servers/1&#39; %&gt;,
    &lt;%== include &#39;GET/servers/2&#39; %&gt;
]
@@ GET/servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ GET/servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
@@ POST/servers.json.ep
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: &lt;%== $c-&gt;req-&gt;body %&gt; }
@@ POST/servers.json+error.ep
% $c-&gt;res-&gt;code( 400 );
{ &quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;Bad request&quot; }
</code></pre>

<p>Now I have 20 lines of code that can be made to mock any JSON API
I write. Mojolicious makes everything easy!</p>


                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/mocking/">mocking</a>
                        <a href="https://mojolicious.io/blog/tag/api/">api</a>
                    </p>

            ]]></description>
            <pubDate>
                Fri, 08 Dec 2017 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 7: Using Template Variants For a Beta Landing Page</title>
            <link>https://mojolicious.io/blog/2017/12/07/day-7-using-template-variants-for-a-beta-landing-page/</link>
            <guid>https://mojolicious.io/blog/2017/12/07/day-7-using-template-variants-for-a-beta-landing-page/</guid>
            <description><![CDATA[
                <p><a href="http://cpantesters.org">CPAN Testers</a> is a pretty big project with a long,
storied history. At its heart is a data warehouse holding all the test reports
made by people installing CPAN modules. Around that exists an ecosystem of
tools and visualizations that use this data to provide useful insight into the
status of CPAN distributions.</p>

<p>For the <a href="http://github.com/cpan-testers/cpantesters-web">CPAN Testers webapp
project</a>, I needed a way to
show off some pre-release tools with some context about what they are and how
they might be made ready for release. I needed a &quot;beta&quot; website with a front
page that introduced the beta projects. But, I also needed the same
<a href="http://mojolicious.org">Mojolicious</a> application to serve (in the future) as a
production website. The front page of the production website would be
completely different from the front page of the beta testing website.</p>

<p>To achieve this, I used <a href="http://mojolicious.org/perldoc/Mojolicious/Guides/Rendering#Template-variants">Mojolicious&#39;s template variants
feature</a>.
First, I created a variant of my index.html template for my beta site
and called it <code>index.html+beta.ep</code>.</p>

<pre><code class="hljs"><span class="hljs-keyword">&lt;h1&gt;</span>CPAN Testers Beta<span class="hljs-keyword">&lt;/h1&gt;</span>
<span class="hljs-keyword">&lt;p&gt;</span>This site shows off some new features currently being tested.<span class="hljs-keyword">&lt;/p&gt;</span>
<span class="hljs-keyword">&lt;h2&gt;&lt;a</span> href=<span class="hljs-string">&quot;/chart.html&quot;</span><span class="hljs-keyword">&gt;</span>Release Dashboard<span class="hljs-keyword">&lt;/a&gt;&lt;/h2&gt;</span>
</code></pre>

<p>Next, I told Mojolicious to use the &quot;beta&quot; variant when in &quot;beta&quot; mode
by passing <code>$app-&gt;mode</code> to the <code>variant</code> stash variable.</p>

<pre><code class="hljs"><span class="hljs-comment"># myapp.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
get &#39;<span class="hljs-string">/*path</span>&#39;, { path =&gt; &#39;<span class="hljs-string">index</span>&#39; }, <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ),
        variant =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">app</span>-&gt;<span class="hljs-type">mode</span>,
    );
};
app-&gt;start;
</code></pre>

<p>The mode is set by passing the <code>-m beta</code> option to Mojolicious&#39;s <code>daemon</code> or
<code>prefork</code> command.</p>

<pre><code>$ perl myapp.pl daemon -m beta
</code></pre>

<p>This gives me the <a href="http://beta.cpantesters.org">new landing page for beta.cpantesters.org</a>.</p>

<pre><code>$ perl myapp.pl get / -m beta
&lt;h1&gt;CPAN Testers Beta&lt;/h1&gt;
&lt;p&gt;This site shows off some new features currently being tested.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;/chart.html&quot;&gt;Release Dashboard&lt;/a&gt;&lt;/h2&gt;
</code></pre>

<p>But now I also need to replace the original landing page (index.html.ep)
so it can still be seen on the beta website. I do this with a simple
trick: I created a new template called <code>web.html+beta.ep</code> that imports
the original template and unsets the <code>variant</code> stash variable. Now
I can see the <a href="http://beta.cpantesters.org/web">main index page on the beta site at
http://beta.cpantesters.org/web</a>.</p>

<pre><code class="hljs">%= include &#39;index&#39;, variant =&gt; undef
</code></pre>

<pre><code>$ perl myapp.pl get /web -m beta
&lt;h1&gt;CPAN Testers&lt;/h1&gt;
&lt;p&gt;This is the main CPAN Testers application.&lt;/p&gt;
</code></pre>

<p>Template variants are a useful feature in some edge cases, and this isn&#39;t the
first time I&#39;ve found a good use for them. I&#39;ve also used them to provide a
different layout template in &quot;development&quot; mode to display a banner saying
&quot;You&#39;re on the development site&quot;. Useful for folks who are undergoing user
acceptance testing. The best part is that if the desired variant for that
specific template is not found, Mojolicious falls back to the main template. I
built a mock JSON API application which made extensive use of this fallback
feature, but that&#39;s another blog post for another time.</p>


                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/rendering/">rendering</a>
                        <a href="https://mojolicious.io/blog/tag/template/">template</a>
                    </p>

            ]]></description>
            <pubDate>
                Thu, 07 Dec 2017 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 6: Adding Your Own Commands</title>
            <link>https://mojolicious.io/blog/2017/12/06/day-6-adding-your-own-commands/</link>
            <guid>https://mojolicious.io/blog/2017/12/06/day-6-adding-your-own-commands/</guid>
            <description><![CDATA[
                <p>Everyone has written those one-off administration or check scripts.
There are probably a few cluttering your project root or bin directory right now.
Those have a problem beyond just the clutter: duplication.</p>

<p>Programmers hate duplication because of skew.
If code gets improved in one place, it is unlikely to be improved in all places, unless there is only the one.
So that script you wrote a while back, the one with the database connection you hand-rolled, is that still correct?</p>

<p>In the <a href="https://mojolicious.io/blog/2017/12/05/day-5-your-apps-built-in-commands">previous article in this series</a> I talked about the built-in commands available to your application.
The final command was <a href="http://mojolicious.org/perldoc/Mojolicious/Command/eval"><code>eval</code></a>.
I mentioned that when combined with predefined behaviors, the command could be great for administrative tasks.
That&#39;s true, but you need to know what to eval in order to do so.</p>

<p>To formalize that process, we can go one step further: defining our own commands.
By doing this your application&#39;s administative behaviors can take arguemnts and provide optional switches as well as give usage messages.
In this way these administative commands decouple themselves from knowledge of the application&#39;s internals and become useful to a broader set of users.</p>

                    <p><a href="https://mojolicious.io/blog/2017/12/06/day-6-adding-your-own-commands/#section-2">Continue reading...</a></p>

                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/command/">command</a>
                        <a href="https://mojolicious.io/blog/tag/example/">example</a>
                    </p>

            ]]></description>
            <pubDate>
                Wed, 06 Dec 2017 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 5: Your App&#39;s Built-In Commands</title>
            <link>https://mojolicious.io/blog/2017/12/05/day-5-your-apps-built-in-commands/</link>
            <guid>https://mojolicious.io/blog/2017/12/05/day-5-your-apps-built-in-commands/</guid>
            <description><![CDATA[
                <p>I mentioned at the outset of this series that Mojolicious applications are more than just web servers.
I then showed how you can start a web server using the <a href="http://mojolicious.org/perldoc/Mojolicious/Command/daemon"><code>daemon</code></a> or <a href="http://mojolicious.org/perldoc/Mojolicious/Command/prefork"><code>prefork</code></a> commands.
In the previous post, I mentioned an <a href="http://mojolicious.org/perldoc/Mojolicious/Command/inflate"><code>inflate</code></a> command that can help you with growing your app from Lite to Full.</p>

<p>But there are other commands, built right in to your app, that can help you be more productive right away!</p>

                    <p><a href="https://mojolicious.io/blog/2017/12/05/day-5-your-apps-built-in-commands/#section-2">Continue reading...</a></p>

                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/command/">command</a>
                        <a href="https://mojolicious.io/blog/tag/debugging/">debugging</a>
                        <a href="https://mojolicious.io/blog/tag/administration/">administration</a>
                    </p>

            ]]></description>
            <pubDate>
                Tue, 05 Dec 2017 00:00:00 +0000
            </pubDate>
        </item>
        <item>
            <title>Day 4: Don&#39;t Fear the Full App</title>
            <link>https://mojolicious.io/blog/2017/12/04/day-4-dont-fear-the-full-app/</link>
            <guid>https://mojolicious.io/blog/2017/12/04/day-4-dont-fear-the-full-app/</guid>
            <description><![CDATA[
                <p>One of the most common misconceptions about Mojolicious is that there is a large difference between the declarative &quot;Lite&quot; apps that we have seen so far and large-scale structured &quot;Full&quot; apps.
Nothing could be further from the truth.
<a href="http://mojolicious.org/perldoc/Mojolicious/Lite">Mojolicious::Lite</a> is a very tiny wrapper around the so-called &quot;Full&quot; app architecture, giving it the approachable keyword syntax.</p>

<p>Because it is much nicer to have concise single-file examples for documentation most of Mojolicious&#39; documentation uses Lite syntax most of the time.
It is understandable that people worry about migrating (or as we call it &quot;growing&quot;) even once their apps would benefit from Object-Oriented structure; after all the docs seem geared towards Lite apps.
However, let those fears go, the transition is easy.
And once you understand it, the documentatation examples are trivial to translate.</p>

<p>Plus, Mojolicious comes with two forms of help when transitioning.
The first is the <a href="http://mojolicious.org/perldoc/Mojolicious/Guides/Growing">Growing Guide</a> which covers everything this post will but from the perspective of porting an existing application (which I won&#39;t duplicate here).
The second is the <a href="http://mojolicious.org/perldoc/Mojolicious/Command/inflate">inflate command</a> which can even start you on the process by moving your templates from the data section and into their own files.</p>

<p>That said, in order to futher demystify things, I&#39;m going to cover some of the differences and pull back the curtain on the Lite syntax itself.</p>

                    <p><a href="https://mojolicious.io/blog/2017/12/04/day-4-dont-fear-the-full-app/#section-2">Continue reading...</a></p>

                    <p>Tags:
                        <a href="https://mojolicious.io/blog/tag/advent/">advent</a>
                        <a href="https://mojolicious.io/blog/tag/lite/">lite</a>
                        <a href="https://mojolicious.io/blog/tag/full/">full</a>
                        <a href="https://mojolicious.io/blog/tag/growing/">growing</a>
                    </p>

            ]]></description>
            <pubDate>
                Mon, 04 Dec 2017 00:00:00 +0000
            </pubDate>
        </item>
    </channel>
</rss>

